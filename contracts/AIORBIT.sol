/*
AIORBIT NFT completely on-chain generated by AI with 6,976,080,000 possibilities.
* Distance: 50-150 pixels (101 possibilities)
* Radius: 20-80 pixels (61 possibilities)
* Rotation speed: 1-30 seconds (30 possibilities)
* Color change speed: 1-10 seconds (10 possibilities)
* Color: 360 possibilities
*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import { Base64 } from "./Base64.sol";

contract AIORBIT is ERC721, Ownable {
    using Counters for Counters.Counter;

    uint256 public constant MAX_TOKENS = 10000;
    uint256 public constant MAX_TOKENS_PER_WALLET = 3;
    uint256 public constant ROYALTY_FEE_PERCENT = 5;
    bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;

    Counters.Counter private _totalTokensMinted;

    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}

    function generateSVG(uint256 _tokenId) internal pure returns (string memory) {
        // Generate random hue and saturation values based on the token ID
        uint256 hue = uint256(keccak256(abi.encodePacked(_tokenId, "hue"))) % 360;
        uint256 sat = uint256(keccak256(abi.encodePacked(_tokenId, "sat"))) % 50 + 50;

        // Generate the fill color string
        string memory color = string(abi.encodePacked("hsl(", Strings.toString(hue), ",", Strings.toString(sat), "%,54%)"));

        // Generate random number of circles between 3 and 5
        uint256 numCircles = uint256(keccak256(abi.encodePacked(_tokenId, "numCircles"))) % 3 + 3;

        // Generate random radius values for each circle
        uint256[] memory radius = new uint256[](numCircles);
        for (uint256 i = 0; i < numCircles; i++) {
            radius[i] = uint256(keccak256(abi.encodePacked(_tokenId, "radius", i))) % 40 + 20;
        }

        // Generate random distance values for each circle
        uint256[] memory distance = new uint256[](numCircles);
        for (uint256 i = 0; i < numCircles; i++) {
            distance[i] = uint256(keccak256(abi.encodePacked(_tokenId, "distance", i))) % 80 + 40;
        }

        // Generate random rotation speed value based on the token ID
        uint256 rotationSpeed = uint256(keccak256(abi.encodePacked(_tokenId, "rotationSpeed"))) % 30 + 1;

        // Generate random color change speed value based on the token ID
        uint256 colorChangeSpeed = uint256(keccak256(abi.encodePacked(_tokenId, "colorChangeSpeed"))) % 10 + 1;

        // Generate the SVG string with multiple circles with random size, rotation speed, color change, and distance from center
        string memory svg = string(
            abi.encodePacked(
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 320">',
                '<rect width="320" height="320" fill="#000"/>',
                '<g transform="translate(160,160)">',
                generateCircle(radius, distance, rotationSpeed),
                '<animateTransform attributeName="transform" type="rotate" from="0 160 160" to="360 160 160" dur="', Strings.toString(rotationSpeed), 's" repeatCount="indefinite"/>',
                '<animate attributeName="fill" values="', color, ';hsl(', Strings.toString(hue + 120), ',', Strings.toString(sat), '%,54%);hsl(', Strings.toString(hue + 240), ',', Strings.toString(sat), '%,54%);', color, '" dur="', Strings.toString(colorChangeSpeed), 's" repeatCount="indefinite"/>',
                '</g>',
                '</svg>'
            )
        );

        return svg;
    }

    function generateCircle(uint256[] memory _radius, uint256[] memory _distance, uint256 _animationDuration) internal pure returns (string memory) {
        require(_radius.length == _distance.length, "Arrays must have the same length");

        string memory circles = "";
        for (uint256 i = 0; i < _radius.length; i++) {
            // Compute the rotation value directly within the loop
            uint256 rotation = uint256(keccak256(abi.encodePacked(i, "rotation"))) % 360;

            string memory circle = string(
                abi.encodePacked(
                    '<circle cx="', Strings.toString(160 + _distance[i]), '" cy="', Strings.toString(160), '" r="', Strings.toString(_radius[i]), '" fill="none" stroke="hsl(', Strings.toString(rotation), ',50%,54%)" stroke-width="2">',
                    '<animateTransform attributeName="transform" type="rotate" from="0 160 160" to="360 160 160" dur="', Strings.toString(_animationDuration - i * 2), 's" repeatCount="indefinite"/>',
                    '<animate attributeName="stroke" values="hsl(', Strings.toString((rotation + 120) % 360), ',50%,54%);hsl(', Strings.toString((rotation + 240) % 360), ',50%,54%);hsl(', Strings.toString(rotation), ',50%,54%)" dur="', Strings.toString(_animationDuration - i * 2), 's" repeatCount="indefinite"/>',
                    '</circle>'
                )
            );
            circles = string(abi.encodePacked(circles, circle));
        }

        return circles;
    }

    function mint(uint256 _numTokens) public {
        require(_totalTokensMinted.current() < MAX_TOKENS, "All tokens have been minted");
        require(balanceOf(msg.sender) + _numTokens <= MAX_TOKENS_PER_WALLET, "Cannot mint more tokens than allowed per wallet");

        for (uint256 i = 0; i < _numTokens; i++) {
            uint256 tokenId = _totalTokensMinted.current() + 1;
            _safeMint(msg.sender, tokenId);
            _totalTokensMinted.increment();
        }
    }

    function royaltyInfo(uint256 _salePrice) external view returns (address receiver, uint256 royaltyAmount) {
        receiver = owner();
        royaltyAmount = (_salePrice * ROYALTY_FEE_PERCENT) / 100;
    }

    function generateAttributes(uint256 _tokenId) internal pure returns (string memory) {
        uint256[] memory radius = generateRadiusValues(_tokenId);
        uint256[] memory distance = generateDistanceValues(_tokenId);

        uint256 hue = uint256(keccak256(abi.encodePacked(_tokenId, "hue"))) % 360;
        uint256 rotationSpeed = uint256(keccak256(abi.encodePacked(_tokenId))) % 30 + 1;
        uint256 colorChangeSpeed = uint256(keccak256(abi.encodePacked(_tokenId, "colorChangeSpeed"))) % 10 + 1;

        string memory attributes = string(
            abi.encodePacked(
                '{"trait_type": "distance", "value": "', Strings.toString(distance[0]), ' - ', Strings.toString(distance[distance.length - 1]), ' pixels"},',
                '{"trait_type": "radius", "value": "', Strings.toString(radius[0]), ' - ', Strings.toString(radius[radius.length - 1]), ' pixels"},',
                '{"trait_type": "rotation_speed", "value": "', Strings.toString(rotationSpeed), ' seconds"},',
                '{"trait_type": "color", "value": "', Strings.toString(hue), ' degrees"},',
                '{"trait_type": "color_change_speed", "value": "', Strings.toString(colorChangeSpeed), ' seconds"}'
            )
        );

        return attributes;
    }

    function generateRadiusValues(uint256 _tokenId) internal pure returns (uint256[] memory) {
        uint256 numCircles = uint256(keccak256(abi.encodePacked(_tokenId, "numCircles"))) % 3 + 3;
        uint256[] memory radius = new uint256[](numCircles);
        for (uint256 i = 0; i < numCircles; i++) {
            radius[i] = uint256(keccak256(abi.encodePacked(_tokenId, "radius", i))) % 40 + 20;
        }
        return radius;
    }

    function generateDistanceValues(uint256 _tokenId) internal pure returns (uint256[] memory) {
        uint256 numCircles = uint256(keccak256(abi.encodePacked(_tokenId, "numCircles"))) % 3 + 3;
        uint256[] memory distance = new uint256[](numCircles);
        for (uint256 i = 0; i < numCircles; i++) {
            distance[i] = uint256(keccak256(abi.encodePacked(_tokenId, "distance", i))) % 80 + 40;
        }
        return distance;
    }

    function tokenURI(uint256 _tokenId) public view override returns (string memory) {
        require(_exists(_tokenId), "Token does not exist");

        // Generate the SVG string
        string memory svg = generateSVG(_tokenId);

        // Get the attribute values
        string memory attributes = generateAttributes(_tokenId);

        // Encode the SVG in base64
        string memory svgBase64 = Base64.encode(bytes(svg));

        // Generate the JSON metadata
        string memory name = string(abi.encodePacked("AIORBIT #", Strings.toString(_tokenId)));
        string memory description = "Orbits generated on-chain by AI with 6,976,080,000 possibilities.";
        string memory imageUri = string(abi.encodePacked("data:image/svg+xml;base64,", svgBase64));
        string memory backgroundColor = "#000000";

        string memory json = string(
            abi.encodePacked(
                '{',
                '"name": "', name, '",',
                '"description": "', description, '",',
                '"image": "', imageUri, '",',
                '"background_color": "', backgroundColor, '",',
                '"attributes": [', attributes, ']',
                '}'
            )
        );

        // Encode the JSON metadata in base64
        string memory jsonBase64 = Base64.encode(bytes(json));

        // Combine the base64-encoded JSON metadata and SVG into the final URI
        return string(abi.encodePacked("data:application/json;base64,", jsonBase64));
    }

    function withdraw() public onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }

    function totalSupply() public view returns (uint256) {
        return _totalTokensMinted.current();
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return super.supportsInterface(interfaceId) || interfaceId == _INTERFACE_ID_FEES;
    }
}